#!/usr/bin/env bash

# KinderCare Classroom sync script (macOS & Linux compatible)
# Requires: curl, jq, exiftool, ffmpeg, ImageMagick (optional for captioning)
# Auth: export your logged-in cookies for classroom.kindercare.com to a file named `cookies.txt`
# Place `cookies.txt` next to this script.

set -euo pipefail
IFS=$'\n\t'

child_id="xxxxx"
no_insert_db=0
caption=0

usage() {
  echo "Usage: $0 [-c] [-i] [-k xxxxxx]" 1>&2
}

exit_abnormal() {
  usage
  exit 1
}

while getopts ":cik:" o; do
  case "${o}" in
    c)
      caption=1
      ;;
    i)
      no_insert_db=1
      ;;
    k)
      child_id=${OPTARG}
      ;;
    :)
      echo "Error: -${OPTARG} requires an argument." 1>&2
      exit_abnormal
      ;;
    *)
      exit_abnormal
      ;;
  esac
done

# Paths
script_dir=$(cd "$(dirname "$0")" && pwd)
work_dir="/tmp/_${child_id}"
out_dir="${script_dir}/${child_id}"
cookies_file="${script_dir}/cookies.txt"
id_db="${out_dir}/id.db"

# Dependency & auth checks
need_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" 1>&2; exit 2; }; }
for cmd in curl jq exiftool ffmpeg; do need_cmd "$cmd"; done

# Image captioning (optional)
convert_bin=""
if [[ "$caption" == "1" ]]; then
  if command -v convert >/dev/null 2>&1; then
    convert_bin="convert"
  elif command -v magick >/dev/null 2>&1; then
    convert_bin="magick convert"
  else
    echo "Captioning requested (-c) but ImageMagick is not installed. Install it or run without -c." 1>&2
    exit 2
  fi
fi

if [[ ! -f "$cookies_file" ]]; then
  echo "cookies.txt not found at $cookies_file. Export your browser cookies for classroom.kindercare.com and save them there." 1>&2
  exit 2
fi

mkdir -p "$out_dir" "$work_dir"
: > "$id_db" # ensure file exists

# Helper: make a safe filename timestamp from ISO-ish input
iso_to_stamp() {
  # Input may look like: 2024-06-04T19:33:27.000-04:00
  local raw="$1"
  local digits
  digits=$(printf '%s' "$raw" | tr -cd '0-9')
  # Expect at least YYYYMMDDHHMMSS
  local y=${digits:0:4}
  local m=${digits:4:2}
  local d=${digits:6:2}
  local H=${digits:8:2}
  local M=${digits:10:2}
  local S=${digits:12:2}
  printf '%s%s%s_%s%s%s' "$y" "$m" "$d" "$H" "$M" "$S"
}

page=1
while :; do
  curl -sS -b "$cookies_file" "https://classroom.kindercare.com/accounts/${child_id}/journal_api?page=${page}" \
    -o "${work_dir}/_act"

  # Any intervals on this page?
  if ! jq -e '.intervals | length > 0' "${work_dir}/_act" >/dev/null 2>&1; then
    break
  fi

  # Flatten activities into one-per-line JSON
  jq -c '.intervals[][] | .activity' "${work_dir}/_act" > "${work_dir}/_jsontemp" || true
  if [[ ! -s "${work_dir}/_jsontemp" ]]; then
    break
  fi

  # Extract fields
  jq -r '.activity_file_id' "${work_dir}/_jsontemp"  > "${work_dir}/_id"
  jq -r '.title // ""'          "${work_dir}/_jsontemp" > "${work_dir}/_title"
  jq -r '.description // ""'    "${work_dir}/_jsontemp" > "${work_dir}/_desc"
  jq -r '.created_at // ""'     "${work_dir}/_jsontemp" > "${work_dir}/_date"
  jq -r '.image.big.url, .video.url | select(. != null)' "${work_dir}/_jsontemp" > "${work_dir}/_img"

  # Portable diff: new IDs not in db (BSD/GNU compatible)
  sort -u "${work_dir}/_id" > "${work_dir}/_id_new"
  sort -u "$id_db" > "${work_dir}/id.db_sorted"
  grep -F -x -v -f "${work_dir}/id.db_sorted" "${work_dir}/_id_new" > "${work_dir}/_delta" || true

  total=$(wc -l < "${work_dir}/_id")
  new=$(wc -l < "${work_dir}/_delta")

  if [[ "$new" -gt 0 ]]; then
    i=1
    while [[ "$i" -le "$total" ]]; do
      id=$(sed -n "${i}p" "${work_dir}/_id")
      if grep -F -x -q "$id" "${work_dir}/_delta"; then
        raw_date=$(sed -n "${i}p" "${work_dir}/_date")
        stamp=$(iso_to_stamp "$raw_date")
        raw_desc=$(sed -n "${i}p" "${work_dir}/_desc")
        raw_title=$(sed -n "${i}p" "${work_dir}/_title")
        # Clean text for metadata/caption (allow letters, numbers, space, basic punct.)
        desc=$(printf '%s' "$raw_desc" | tr -dc '[:alnum:][:space:][.!?]\n\r' || true)
        title=$(printf '%s' "$raw_title" | tr -dc "[:alnum:][:space:][.!?']\n\r" || true)
        img=$(sed -n "${i}p" "${work_dir}/_img")

        # Remove boilerplate if present
        title=${title/Look what I\'m doing today!/}
        desc=${desc/Look what I\'m doing today!/}

        if printf '%s' "$img" | grep -q "activity_file/video"; then
          # Video
          curl -sSL "$img" -o "${out_dir}/${stamp}.mov"
          echo "converting video: ${stamp}.mov -> ${stamp}.mp4"
          ffmpeg -loglevel error -y -i "${out_dir}/${stamp}.mov" -metadata title="$title $desc" "${out_dir}/${stamp}.mp4"
          rm -f "${out_dir}/${stamp}.mov"
        else
          # Photo
          curl -sSL "$img" -o "${out_dir}/${stamp}.jpg"
          exiftool -overwrite_original -XPcomment="$desc" -title="$title $desc" "${out_dir}/${stamp}.jpg" >/dev/null 2>&1 || true
          if [[ "$caption" == "1" ]] && [[ -n "$convert_bin" ]] && { [[ -n "$title" ]] || [[ -n "$desc" ]]; }; then
            width=$(exiftool -s -s -s -ImageWidth "${out_dir}/${stamp}.jpg" 2>/dev/null || echo 0)
            [[ "$width" =~ ^[0-9]+$ ]] || width=0
            if [[ "$width" -gt 0 ]]; then
              # Append a caption panel of same width; ImageMagick v6/v7 supported
              eval "$convert_bin \"${out_dir}/${stamp}.jpg\" -background lightgray -size ${width}x -pointsize 20 caption:\"$title $desc\" -gravity center -append \"${out_dir}/__tmp_${stamp}.jpg\"" >/dev/null 2>&1 || true
              if [[ -f "${out_dir}/__tmp_${stamp}.jpg" ]]; then
                mv -f "${out_dir}/__tmp_${stamp}.jpg" "${out_dir}/${stamp}.jpg"
              fi
            fi
          fi
        fi
      fi
      i=$(( i + 1 ))
    done
  else
    # No new IDs on this page; stop
    break
  fi

  # Next page
  page=$(( page + 1 ))

  # Update DB and tidy
  if [[ "$no_insert_db" == "0" ]]; then
    cat "${work_dir}/_delta" >> "$id_db"
    sort -u "$id_db" > "${work_dir}/id.db_sorted"
    mv "${work_dir}/id.db_sorted" "$id_db"
  fi
  rm -f "${work_dir}/_act" "${work_dir}/_id" "${work_dir}/_title" "${work_dir}/_desc" "${work_dir}/_date" "${work_dir}/_img" "${work_dir}/_delta" "${work_dir}/_jsontemp"
done

# Final DB dedupe (safety)
sort -u "$id_db" -o "$id_db"
